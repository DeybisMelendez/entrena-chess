<chess-board
    style="width: 400px"
    position="{{ puzzle.fen }}"
    orientation="{{ puzzle.orientation }}"
    draggable-pieces>
</chess-board>

<script>
function puzzleInit(fen) {
    const board = document.querySelector('chess-board');
    const game = new Chess(fen);

    // Lista de movimientos como UCI: ["e8d7", "a2e6", ...]
    const solutionMoves = {{ puzzle.moves|safe }};
    let moveIndex = 0;
    let puzzleFailed = false;

    const opponentMove = solutionMoves[moveIndex];

    if (opponentMove) {
        setTimeout(() => {
            // aplicar jugada del rival
            const from = opponentMove.slice(0, 2);
            const to = opponentMove.slice(2, 4);
            console.log("Oponente mueve: " + opponentMove);

            game.move({ from, to, promotion: 'q' });
            board.setPosition(game.fen());

            moveIndex++;

        }, 600); // pequeÃ±o delay para que se vea natural
    }

    // AcciÃ³n: jugador mueve
    board.addEventListener('drag-start', (e) => {
        const { piece } = e.detail;

        // no permitir mover si puzzle fallado
        if (puzzleFailed) {
            e.preventDefault();
            return;
        }

        // no permitir mover si la partida ya estÃ¡ terminada
        if (game.game_over()) {
            e.preventDefault();
            return;
        }

        // solo permitir mover el color que le toca
        if ((game.turn() === 'w' && piece.startsWith('b')) ||
            (game.turn() === 'b' && piece.startsWith('w'))) {
            e.preventDefault();
            return;
        }
    });

    board.addEventListener('drop', (e) => {
        const { source, target, setAction } = e.detail;

        if (puzzleFailed) {
            setAction('snapback');
            return;
        }

        const attemptedUci = source + target;
        const correctMove = solutionMoves[moveIndex];

        const tentative = game.move({
            from: source,
            to: target,
            promotion: "q"
        });

        if (tentative === null) {
            // Movimiento ilegal â†’ snapback sin fallar puzzle
            console.log("âŒ Ilegal: " + attemptedUci);
            setAction("snapback");
            return;
        }

        if (attemptedUci !== correctMove) {
            console.log("âŒ Legal pero incorrecto: " + attemptedUci);
            puzzleFailed = true;
            setAction("snapback");

            // revertir el movimiento que chess.js hizo
            game.undo();

            alert("âŒ Movimiento incorrecto");
            return;
        }

        console.log("âœ” Correcto: " + attemptedUci);
        board.setPosition(game.fen());
        moveIndex++;

        const opponentMove = solutionMoves[moveIndex];
        if (opponentMove) {
            setTimeout(() => {
                const from = opponentMove.slice(0, 2);
                const to = opponentMove.slice(2, 4);

                console.log("ðŸ¤– Rival mueve: " + opponentMove);
                game.move({ from, to, promotion: "q" });
                board.setPosition(game.fen());

                moveIndex++;

            }, 600);
        }
    });


    // mantener tablero sincronizado
    board.addEventListener('snap-end', () => {
        board.setPosition(game.fen());
    });
}
puzzleInit("{{ puzzle.fen }}");
</script>
